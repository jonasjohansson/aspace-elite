<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
<title>Receiver</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  html, body { width: 100%; height: 100%; overflow: hidden; background: #000; font-family: 'Inter', sans-serif; }
  #display { display: flex; width: 100vw; height: 100vh; }
  .column { position: relative; display: flex; align-items: center; justify-content: center; overflow: hidden; }
  .column video { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; display: none; }
  .column video.visible { display: block; }
  .column-text { position: relative; z-index: 1; font-size: 4vw; font-weight: bold; text-align: center; padding: 2%; word-wrap: break-word; }
  #col1 { background: #ffffff; flex: 4752; }
  #gap { background: #000; flex: 1901; }
  #col2 { background: #0000ff; flex: 5940; }
  #status { position: fixed; top: 8px; right: 8px; width: 10px; height: 10px; border-radius: 50%; background: #f44; z-index: 1000; }
  #status.connected { background: #4f4; }
  #latency-display { position: fixed; top: 8px; left: 8px; color: rgba(255,255,255,0.4); font-size: 10px; font-family: monospace; z-index: 1000; }
  #burst-indicator { position: fixed; bottom: 8px; right: 8px; color: rgba(255,255,255,0.4); font-size: 10px; font-family: monospace; z-index: 1000; }
  #logo { position: fixed; bottom: 16px; right: 16px; height: 40px; z-index: 1000; }
  .trail-canvas {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    pointer-events: none;
    z-index: 2;
    mix-blend-mode: difference;
  }
  .bouncer {
    position: absolute;
    width: 80px;
    height: 80px;
    pointer-events: none;
    z-index: 3;
    mix-blend-mode: difference;
  }
</style>
</head>
<body>
<div id="status"></div>
<div id="latency-display"></div>
<div id="burst-indicator"></div>
<img id="logo" src="logo.png" alt="logo">
<div id="display">
  <div id="col1" class="column">
    <video id="video1" src="test1.mp4" autoplay muted loop playsinline></video>
    <canvas class="trail-canvas" id="trail1"></canvas>
    <div class="column-text" id="text1">Hello</div>
    <div class="bouncer" id="shape1"></div>
  </div>
  <div id="gap"></div>
  <div id="col2" class="column">
    <video id="video2" src="test2.mp4" autoplay muted loop playsinline></video>
    <canvas class="trail-canvas" id="trail2"></canvas>
    <div class="column-text" id="text2">World</div>
    <div class="bouncer" id="shape2"></div>
  </div>
</div>
<script src="https://cdn.socket.io/4.7.4/socket.io.min.js"></script>
<script>
  const socket = io('https://aspace-elite-server.onrender.com');
  const col1 = document.getElementById('col1');
  const col2 = document.getElementById('col2');
  const gap = document.getElementById('gap');
  const text1 = document.getElementById('text1');
  const text2 = document.getElementById('text2');
  const video1 = document.getElementById('video1');
  const video2 = document.getElementById('video2');
  let messageCount = 0, lastMessageTime = Date.now();

  socket.on('connect', () => {
    document.getElementById('status').className = 'connected';
    socket.emit('register', 'receiver');
  });
  socket.on('disconnect', () => { document.getElementById('status').className = ''; });

  socket.on('settings', (data) => {
    messageCount++;
    const now = Date.now();
    document.getElementById('latency-display').textContent = `msgs: ${messageCount} | delta: ${now - lastMessageTime}ms`;
    lastMessageTime = now;

    if (data.col1Width !== undefined) col1.style.flex = data.col1Width;
    if (data.col2Width !== undefined) col2.style.flex = data.col2Width;
    if (data.gapWidth !== undefined) gap.style.flex = data.gapWidth;
    if (data.col1Color !== undefined) col1.style.background = data.col1Color;
    if (data.col2Color !== undefined) col2.style.background = data.col2Color;
    if (data.gapColor !== undefined) gap.style.background = data.gapColor;
    if (data.text1 !== undefined) text1.textContent = data.text1;
    if (data.text2 !== undefined) text2.textContent = data.text2;
    if (data.text1Color !== undefined) text1.style.color = data.text1Color;
    if (data.text2Color !== undefined) text2.style.color = data.text2Color;
    if (data.fontSize !== undefined) { text1.style.fontSize = data.fontSize; text2.style.fontSize = data.fontSize; }
    if (data.showVideo1 !== undefined) video1.className = data.showVideo1 ? 'visible' : '';
    if (data.showVideo2 !== undefined) video2.className = data.showVideo2 ? 'visible' : '';
    if (data.shapeSpeed !== undefined) shapeSpeed = data.shapeSpeed;
    if (data.trails !== undefined) trailAmount = data.trails;
    if (data.col1Color !== undefined) { col1Color = data.col1Color; shape2.style.background = data.col1Color; }
    if (data.col2Color !== undefined) { col2Color = data.col2Color; shape1.style.background = data.col2Color; }
    if (data.pulse) doExplode();
  });

  socket.on('ping-test', (data) => { data.receiverGot = Date.now(); socket.emit('pong-test', data); });

  let burstReceived = 0, burstTotal = 0, burstStart = 0;
  socket.on('burst', (data) => {
    if (data.index === 0) { burstReceived = 0; burstTotal = data.total; burstStart = Date.now(); }
    burstReceived++;
    const el = document.getElementById('burst-indicator');
    if (burstReceived === burstTotal) {
      const elapsed = Date.now() - burstStart;
      el.textContent = `burst: ${burstTotal} in ${elapsed}ms (${(burstTotal/elapsed*1000).toFixed(0)} msg/s)`;
      socket.emit('burst-ack', { total: burstTotal, elapsed, rate: burstTotal/elapsed*1000 });
    } else {
      el.textContent = `burst: ${burstReceived}/${burstTotal}`;
    }
  });

  // Shape system
  const shape1 = document.getElementById('shape1');
  const shape2 = document.getElementById('shape2');
  const tc1 = document.getElementById('trail1');
  const tc2 = document.getElementById('trail2');
  const ctx1 = tc1.getContext('2d');
  const ctx2 = tc2.getContext('2d');

  const BASE_SIZE = 80;
  let shapeSpeed = 3, trailAmount = 0;
  let col1Color = '#ffffff', col2Color = '#0000ff';
  let currentSize = BASE_SIZE;
  let shapeIdx = 0;
  let exploding = false, explodeTime = 0;
  let particles = [];

  const clipShapes = [
    ['none', '0'],
    ['none', '50%'],
    ['polygon(50% 0%, 100% 100%, 0% 100%)', '0'],
    ['polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%)', '0'],
    ['polygon(25% 0%, 75% 0%, 100% 50%, 75% 100%, 25% 100%, 0% 50%)', '0'],
  ];

  function applyClip(el, idx) {
    el.style.clipPath = clipShapes[idx][0];
    el.style.borderRadius = clipShapes[idx][1];
  }

  // Canvas shape drawing for trails
  function drawShape(ctx, x, y, size, shapeIndex, color) {
    ctx.fillStyle = color;
    ctx.beginPath();
    const h = size / 2;
    switch (shapeIndex) {
      case 0: ctx.rect(x - h, y - h, size, size); break;
      case 1: ctx.arc(x, y, h, 0, Math.PI * 2); break;
      case 2: ctx.moveTo(x, y - h); ctx.lineTo(x + h, y + h); ctx.lineTo(x - h, y + h); break;
      case 3: ctx.moveTo(x, y - h); ctx.lineTo(x + h, y); ctx.lineTo(x, y + h); ctx.lineTo(x - h, y); break;
      case 4:
        for (let i = 0; i < 6; i++) {
          const a = Math.PI / 3 * i - Math.PI / 2;
          const px = x + h * Math.cos(a), py = y + h * Math.sin(a);
          i === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
        }
        break;
    }
    ctx.closePath();
    ctx.fill();
  }

  function doExplode() {
    exploding = true;
    explodeTime = Date.now();
    particles = [];
    for (let i = 0; i < 30; i++) {
      const angle = Math.random() * Math.PI * 2;
      const speed = 3 + Math.random() * 8;
      particles.push({
        x: sx, y: sy,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        size: 4 + Math.random() * 12,
        life: 1
      });
    }
    shape1.style.display = 'none';
    shape2.style.display = 'none';
  }

  function resizeCanvases() {
    const r1 = col1.getBoundingClientRect();
    const r2 = col2.getBoundingClientRect();
    tc1.width = r1.width; tc1.height = r1.height;
    tc2.width = r2.width; tc2.height = r2.height;
  }

  let sx, sy, svx = 3, svy = 2;

  function initShapes() {
    const r1 = col1.getBoundingClientRect();
    sx = r1.left + r1.width / 2;
    sy = window.innerHeight / 2;
    shape1.style.background = '#0000ff';
    shape2.style.background = '#ffffff';
    applyClip(shape1, 0);
    applyClip(shape2, 0);
    resizeCanvases();
  }

  window.addEventListener('resize', resizeCanvases);

  function animate() {
    const r1 = col1.getBoundingClientRect();
    const r2 = col2.getBoundingClientRect();
    const h = window.innerHeight;

    // Resize canvases if needed
    if (tc1.width !== Math.round(r1.width)) resizeCanvases();

    // Fade trails
    const fade = trailAmount > 0 ? (1 - trailAmount) * 0.3 + 0.01 : 1;
    ctx1.globalCompositeOperation = 'destination-out';
    ctx1.fillStyle = `rgba(0,0,0,${fade})`;
    ctx1.fillRect(0, 0, tc1.width, tc1.height);
    ctx1.globalCompositeOperation = 'source-over';
    ctx2.globalCompositeOperation = 'destination-out';
    ctx2.fillStyle = `rgba(0,0,0,${fade})`;
    ctx2.fillRect(0, 0, tc2.width, tc2.height);
    ctx2.globalCompositeOperation = 'source-over';

    if (exploding) {
      const elapsed = Date.now() - explodeTime;
      const duration = 1000;
      const convergeStart = 600;

      particles.forEach(p => {
        if (elapsed < convergeStart) {
          p.x += p.vx;
          p.y += p.vy;
          p.vx *= 0.96;
          p.vy *= 0.96;
        } else {
          const t = (elapsed - convergeStart) / (duration - convergeStart);
          p.x += (sx - p.x) * 0.1;
          p.y += (sy - p.y) * 0.1;
        }
        p.life = Math.max(0, 1 - elapsed / duration);

        // Draw particle on both canvases
        const lx1 = p.x - r1.left;
        const lx2 = p.x - r2.left;
        const ly = p.y;
        const a = p.life;
        ctx1.globalAlpha = a;
        ctx1.fillStyle = col2Color;
        ctx1.fillRect(lx1 - p.size / 2, ly - p.size / 2, p.size, p.size);
        ctx2.globalAlpha = a;
        ctx2.fillStyle = col1Color;
        ctx2.fillRect(lx2 - p.size / 2, ly - p.size / 2, p.size, p.size);
      });
      ctx1.globalAlpha = 1;
      ctx2.globalAlpha = 1;

      if (elapsed >= duration) {
        exploding = false;
        shape1.style.display = '';
        shape2.style.display = '';
        shapeIdx = (shapeIdx + 1) % clipShapes.length;
        applyClip(shape1, shapeIdx);
        applyClip(shape2, shapeIdx);
      }

      requestAnimationFrame(animate);
      return;
    }

    // Normal movement
    const dir = svx > 0 ? 1 : -1;
    const dirY = svy > 0 ? 1 : -1;
    svx = dir * shapeSpeed;
    svy = dirY * (shapeSpeed * 0.66);
    sx += svx;
    sy += svy;

    currentSize = BASE_SIZE;
    const half = currentSize / 2;

    if (sy - half <= 0) { sy = half; svy = Math.abs(svy); }
    if (sy + half >= h) { sy = h - half; svy = -Math.abs(svy); }

    if (sx - half <= r1.left) {
      sx = r1.left + half;
      svx = Math.abs(svx);
      shapeIdx = (shapeIdx + 1) % clipShapes.length;
      applyClip(shape1, shapeIdx);
      applyClip(shape2, shapeIdx);
    }

    if (sx + half >= r2.right) {
      sx = r2.right - half;
      svx = -Math.abs(svx);
      shapeIdx = (shapeIdx + 1) % clipShapes.length;
      applyClip(shape1, shapeIdx);
      applyClip(shape2, shapeIdx);
    }

    // Draw trails on canvases
    if (trailAmount > 0) {
      const lx1 = sx - r1.left;
      const lx2 = sx - r2.left;
      drawShape(ctx1, lx1, sy, currentSize, shapeIdx, col2Color);
      drawShape(ctx2, lx2, sy, currentSize, shapeIdx, col1Color);
    }

    // Position div shapes
    const localX1 = sx - r1.left - half;
    const localX2 = sx - r2.left - half;
    shape1.style.left = localX1 + 'px';
    shape1.style.top = (sy - half) + 'px';
    shape2.style.left = localX2 + 'px';
    shape2.style.top = (sy - half) + 'px';

    requestAnimationFrame(animate);
  }

  initShapes();
  requestAnimationFrame(animate);
</script>
</body>
</html>
